# 八股
操作系统调度计算机 的工作和资源分配，为用户和其他软件提供服务，是计算机系统中基本的系统软件

## 基础知识

#### 操作系统的特征

- 并发：多个事件同一时间间隔发生。计算机系统中同时存在多个运行的程序，所以可以同时 调度多个程序 （并行是同一时刻，和并发不同）
- 共享：系统中的资源可以给多个并发执行的进程一起用
	- 互斥共享：一段时间内只允许一个进程访问该资源
	- 同时反问：本质是交替快速访问
- 虚拟：物理上的实体变成逻辑上的对应物
- 异步：进程的执行不是到底，而是以不可预知速度推进

####  操作系统的角色和功能
位于硬件之上，管理硬件。位于应用程序之下，为应用程序提供服务
重要的硬件资源：CPU，内存，硬盘，I/O 设备

1. 资源的分配
   比如多个进程请求 CPU 怎么分，内存怎么分，内存碎片化，访问错误等问题
	还要考虑资源的回收
2. 为应用程序提供服务
   将硬件资源封装，提供统一接口给上层应用的开发者调用
3. 管理应用程序
   控制进程生命周期，环境配置，资源配置，进程结束后的资源回收和进程调度等

开机后跑的第一个就是操作系统，应用都跑在操作系统上，应用调用进程，进程结束操作系统会回收。

## 进程和线程

#### 进程基础理解
###### 概念
- 编写代码->存储在硬盘，静态文件->编译后产生二进制可执行文件->运行后装到内存中->CPU 执行一条条指令 ->运行中的程序就是进程
- 进程：具有独立功能的程序在数据集合上运行的过程，是系统进行资源分配和调度的独立单位
###### PCB 块
- 进程控制块 PCB：进程存在的唯一标识，标志进程的基本情况和运行状态，包括
  1. 进程描述信息：进程标识符，用户标识符
  2. 进程控制和管理信息：进程状态和优先级
  3. 进程资源怎么分配，内存，虚拟空间地址，调用的 IO 等
  4. CPU 相关信息，方便快速调用
	一般通过队列方式组织PCB

###### 并发和并行
- 单个处理核心短时间内处理多个进程->并发
- 多个处理核心处理多个进程->并行
并发需要记录当前进程中运行状态信息，方便切换回来的时候恢复执行

######  进程状态切换
进程有以下几种状态：
- 运行态：占用 CPu
- 就绪态：可以运行，其他进程在运行所以暂停运行
- 阻塞态：等待某一个事件（比如输入/输出操作）发生 暂时停止运行
大量处于阻塞态的进程就会占用很多物理内存，这时候换入硬盘就没有占用实际的物理内存空间，就叫“挂起”。挂起也分为阻塞挂起（等事件）和就绪挂起（进入内存马上执行）    （就绪也是可以被放进去滴）    

阻塞和就绪的转换都是要找到对应的 PCB

流程图：
![[../attachments/Pasted image 20250506211505.png]]
只有就绪和运行态可以相互转换  （看 CPU 分的时间）

###### 进程上下文切换
进程切换到另一个进程就是上下文切换。切换包括虚拟内存，栈，全局变量等空间资源。

时间片耗尽，阻塞等待，中断处理，高优先级先执行，通过 sleep 主动挂起自己
这些的方法会实现上下文的切换

###### 进程创建
一个进程可以创建另外的进程，创建者为父进程，被创建的是子进程
创建新进程的流程：
1. 分配 PCB控制块
2. 分配所需资源如内存，CPU 时间
3. 初始化 PCB 各种字段，包括状态，优先级等
4. 初始状态设置为就绪，放图入就绪队列

###### 进程终止
流程：
1. 根据标识符找到 PCB
2. 如果执行就马上终止然后处理器资源（CPU 核心等）分配给别的进程
3. 如果有子进程就酱该进程的子进程交给 1 号进程（第一个用户态进程，可以避免僵尸进程堆积等功能呢，还有系统初始化和进程管理的作用）接管
4. 进程资源（代码段，数据段，堆栈，PCB 等）归还操作系统
5. 删除队列中的 PCB


#### 线程基础
###### 概念
线程是轻量级进程，是进程中的一个实体。是被系统独立调度和分配的基本单位

###### 线程的特点
- 同一进程中的各个线程共享该进程的资源（代码段，数据段，打开的文件，用户 ID 和组 ID，工作目录，文件描述符表等）但是每个线程都有独立的寄存器和栈（线程 id，调度优先级等也都不一样）
- 进程可以蜕变为线程
- 线程函数可以并发执行
- 线程不拥有系统资源但是也有 PCB，创建线程实用的底层函数和进程一样都是 clone （内核函数）
	- 本质上如果是复制地址就是产生进程，共享地址就是线程

###### 进程和线程的比较
进程是资源分配的单位而线程是 CPU 调度的单位
- 线程除了寄存器和栈外基本没有几元啊，线程可以访问隶属进程的系统资源
- 调度：同一进程中线程切换不换进程但是一个进程中线程换到另一个进程中线程会换进程
- 并发：进程可以并发，一个进程中的多个线程可以并发，不同进程中的线程也可并发执行
- 独立性：进程有独立的地址空间和资源，除了全局变量以外不允许别的进程访问。进程中的线程对别的进程视而不见，统一进程中的线程是为了并发性和互相合作而建立的
- 系统开销：线程更小，比如创建时间块，切换块，终止快，数据传递快 （就在进程中，不用过内核）（进程的切换涉及到 CPU 寄存器，虚拟内存空间，程序计数器，页表切换等）

线程的状态也是：执行，就绪（需要获得 CPU），阻塞（执行中因事件受阻）

###### 线程的实现
GO 语言中的 MGP 模型，M （Machine）就是内核线程，由操作系统调度，G（goroutine）是用户级线程，P（processor）维护本地 goroutine队列决定哪些 Goroutine 可被调度到 M 执行

1. 用户线程（ULT）
   在用户空间实现，不受内核管理，线程管理和调度操作系统不直接参与，而是由用户级的线程库函数完成线程管理，包括线程的创建，终止，同步，调度等
2. 内核线程（KLT）
   由操作系统管理调度，对应 TCB和 PCB 存放在内核中，创建终止管理都是由操作系统负责 
	内核线程发起调用阻塞时不会影响别的内核线程执行
3. 轻量级线程（LWP）
   是内核支持的用户线程，每个 LWP 和内核线程一对一映射。由内核管理但是和普通线程一样调度

#### 进程调度
###### 调度目标
以下几个角度考虑调度算法性能
 - CPU 利用率：有没有充分利用
 - 系统吞吐量：单位时间内 CPU 完成的作业数
 - 周转事件：作业从提交到完成的时间，包括等待排队，处理和输出等
 - 等待时间：进程处于等待处理的时间和
 - 响应时间：用户请求到系统响应的时间

###### 进程调度方式
- 抢占式：一个进程处理中有更加重要的进程进入到就绪队列中，就运行调度程序先暂停现在的，优先处理更高级的
- 非抢占式：同上面的相反，让原来的继续执行

###### 进程调度算法
1. 未来先服务算法：每次从就绪队列选择最先进入队列的进程，然后一直运行直到退出退出或者阻塞，再选下一个（对长时间作业有利）
2. 最短作业算法（SJF）：从队列中优先选择估计运行时间最短的作业，放入内存中运行，可以提高系统吞吐量 （长作业不友好也没有考虑优先级）
3. 高响应比优先调度算法：优先权= （等待时间+要求服务时间）/要求服务时间
4. 时间⽚轮转调度算法：类似银行排队，给每个人都办理 1min，轮着来。时间到了就从 CPU 中放出来
5. 最⾼优先级调度算法：就绪队列中选择最⾼优先级的进程进⾏运⾏，优先级分为静态（创建进程的时候确定的）和动态（进程运行过程中根据运行时间，等待时间等调整。）  这会让优先级低的可能永远没法执行
6. 多级队列调度算法：每个就绪队列的算法不一样
7. 多级反馈队列调度算法：融合时间片轮转和最高优先级调度。队列的优先级从高到底，然后越高级的队列时间片越小
 快速理解多级反馈队列大致含义：
 ![[../attachments/Pasted image 20250507103554.png]]

#### 进程通信
######  共享存储
在通信的进程存在一块可以直接访问你的共享空间，对这片空间进行写/读操作

###### 消息队列（消息传递）
如果没有共享的访问空间，就会操作系统提供方法
- 直接通信：发送进程发送到接收方的消息缓冲队列上
- 间接通信：发送进程将消息发送到一个中间实体，接受进程从中间实体上取得消息

消息队列不适合大数据传输

###### 管道
连接一个写进程和一个读进程，实现通信的一个共享文件
- 管道传输是半双工的
- 先入先出
- 无格式，需要事先约定
- 管道不是普通文件，存在于内存中
- 管道对应缓冲区，不同系统的管道不一样

###### 信号量
用于管理 A 和 B 两个进程之间谁来阻塞的方式

###### socket通信
是⼀种⽹络编程中常⻅的通信⽅式
包括通过 TCP 实现和 UDP 实现

###### 信号
信号用于响应各种各样的事件，kill -l 查看所有的信号

#### 线程通信
线程通信用于线程同步，没有像进程通信一样用于数据交换通信机制
同一进程的不同线程共享同一份内存，所以通信方便。数据复制到共享变量中就行。 不过记得不同线程不要同时修改用一份信息，会有并发问题


#### 线程属性
1. 线程初始化和销毁
2. 线程分离状态
	- 设置分离线程等，可以让线程多等待让函数 pthread 返回
3. 线程栈地址
	- 进程地址空间不够，malloc 分配空间作为栈空间
4. 线程栈大小
5. 线程使用注意事项
	- 主线程退出别的线程不退出主线程应该调用 pthread_exit
	- 避免僵尸进程  (pthread相关操作)

#### 多线程
好处： 应用中同时多个活动，随着时间推移阻塞，这些应用程序分解为并发运行的多个线程 -> 有共享统一地址空间和可用数据的能力






# 实用
